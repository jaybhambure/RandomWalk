\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{hyperref}

% Code listing style
\lstset{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    frame=single,
    breaklines=true,
    captionpos=b
}

\pagestyle{fancy}
\fancyhf{}
\rhead{1D Random Walk with PETSc}
\lhead{Code Documentation}
\cfoot{\thepage}

\title{1D Random Walk Implementation\\Short Code Notes}
\author{PETSc + HDF5 Implementation}
\date{\today}

\begin{document}

\maketitle

\section{Overview}

This code implements a 1D random walk simulation using PETSc's Distributed Mesh (DMDA) framework with HDF5 output for data visualization and analysis.

\subsection{Key Features}
\begin{itemize}
    \item Multiple walker simulation on a periodic 1D grid
    \item PETSc DMDA for structured grid management
    \item HDF5 output for trajectory and final position data
    \item Python plotting integration
\end{itemize}

\section{Code Structure}

\subsection{Simulation Parameters}
\begin{lstlisting}[caption=Core simulation parameters]
PetscInt grid_size = 100;      // 1D grid size
PetscInt num_steps = 1000;     // Time steps
PetscInt num_walkers = 1000;   // Number of walkers
\end{lstlisting}

\textbf{Key Points:}
\begin{itemize}
    \item Grid uses periodic boundary conditions: position wraps around
    \item Walker count easily adjustable for different simulation scales
    \item Step count determines simulation length
\end{itemize}

\subsection{PETSc DMDA Setup}

\begin{lstlisting}[caption=1D DMDA creation with periodic boundaries]
DM da;
ierr = DMDACreate1d(PETSC_COMM_SELF, DM_BOUNDARY_PERIODIC, 
                    grid_size, dof, stencil_width, NULL, &da);
\end{lstlisting}

\textbf{Purpose:}
\begin{itemize}
    \item \texttt{PETSC\_COMM\_SELF}: Single process execution
    \item \texttt{DM\_BOUNDARY\_PERIODIC}: Periodic boundary conditions
    \item \texttt{dof = 1}: One degree of freedom per grid point
    \item \texttt{stencil\_width = 1}: Nearest neighbor stencil
\end{itemize}

\subsection{Data Structures}

\subsubsection{Walker Density Vector}
\begin{lstlisting}[caption=Grid-based walker density]
Vec walker_density;
ierr = DMCreateGlobalVector(da, &walker_density);
\end{lstlisting}

\textbf{Function:} Stores number of walkers at each grid position
\begin{align}
\text{walker\_density}[i] = \sum_{k=1}^{N} \delta_{x_k, i}
\end{align}
where $\delta_{x_k, i} = 1$ if walker $k$ is at position $i$, else $0$.

\subsubsection{Individual Walker Tracking}
\begin{lstlisting}[caption=Walker position arrays]
std::vector<PetscInt> walker_positions(num_walkers);
std::vector<std::vector<PetscInt>> trajectories(num_walkers);
\end{lstlisting}

\textbf{Purpose:}
\begin{itemize}
    \item \texttt{walker\_positions}: Current position of each walker
    \item \texttt{trajectories}: Complete path history for plotting
\end{itemize}

\section{Algorithm}

\subsection{Initialization}
Walkers are uniformly distributed across the grid:
\begin{align}
x_w^{(0)} = \frac{\text{grid\_size}}{N} \cdot w + \frac{\text{grid\_size}}{2N}
\end{align}
where $w \in \{0, 1, ..., N-1\}$ and $N$ is the number of walkers.

\subsection{Random Walk Step}
Each time step, every walker moves randomly:
\begin{lstlisting}[caption=Single random step]
PetscInt random_step = (step_choice(gen) == 0) ? -1 : 1;
walker_positions[w] += random_step;
walker_positions[w] = (walker_positions[w] + grid_size) % grid_size;
\end{lstlisting}

\textbf{Mathematical representation:}
\begin{align}
x_w^{(t+1)} = (x_w^{(t)} + s_w^{(t)}) \mod L
\end{align}
where $s_w^{(t)} \in \{-1, +1\}$ with equal probability and $L$ is the grid size.

\subsection{Density Update}
After each step, the grid density is recalculated:
\begin{lstlisting}[caption=Density vector update]
ierr = VecZeroEntries(walker_density);  // Clear grid
for (PetscInt w = 0; w < num_walkers; w++) {
    ierr = VecSetValue(walker_density, walker_positions[w], 
                       1.0, ADD_VALUES);
}
\end{lstlisting}

\section{Data Output}

\subsection{HDF5 Structure}
The simulation generates \texttt{randWalk1d\_data.h5} with:

\begin{table}[h]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Dataset} & \textbf{Type} & \textbf{Description} \\
\hline
\texttt{final\_positions} & Vector & Final position of each walker \\
\texttt{trajectories} & Flattened Matrix & Complete walker paths (sampled) \\
\hline
\end{tabular}
\end{table}

\textbf{Attributes:}
\begin{itemize}
    \item \texttt{grid\_size}: Grid dimensions
    \item \texttt{num\_walkers}: Walker count
    \item \texttt{num\_steps}: Total simulation steps
    \item \texttt{num\_time\_points}: Trajectory sampling points
\end{itemize}

\subsection{Trajectory Sampling}
To reduce data size, trajectories are sampled every 10 steps:
\begin{lstlisting}[caption=Trajectory storage optimization]
if (i % 10 == 0) {
    trajectories[w].push_back(walker_positions[w]);
}
\end{lstlisting}

\section{Key Physics}

\subsection{Expected Behavior}
For a 1D random walk with $N$ steps:
\begin{align}
\langle x^2 \rangle &= N \\
\text{RMS displacement} &= \sqrt{N}
\end{align}

\subsection{Periodic Boundaries}
The displacement calculation must account for periodic wrapping:
\begin{align}
\Delta x = \min(|x_f - x_0|, L - |x_f - x_0|)
\end{align}

\section{Usage}

\subsection{Compilation and Execution}
\begin{lstlisting}[language=bash, caption=Build and run commands]
make run    # Compile and execute simulation
make plot   # Generate displacement and trajectory plots
\end{lstlisting}

\subsection{Parameter Modification}
To change simulation parameters, edit the values directly in \texttt{randomWalk1d.cpp}:
\begin{lstlisting}[caption=Easy parameter adjustment]
PetscInt num_walkers = 50;   // Change walker count here
PetscInt num_steps = 500;    // Change simulation length
\end{lstlisting}

\section{Extensions}

This implementation provides a foundation for:
\begin{itemize}
    \item 2D/3D random walks using \texttt{DMDACreate2d/3d}
    \item Biased random walks (drift terms)
    \item Multiple species with different step sizes
    \item Obstacle incorporation via boundary conditions
    \item Parallel execution with \texttt{PETSC\_COMM\_WORLD}
\end{itemize}

\end{document}